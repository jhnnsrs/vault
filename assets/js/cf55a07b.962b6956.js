"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2161],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||i;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4032:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return u}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],s={id:"ressources",title:"Ressource Management",sidebar_label:"Ressource Management",slug:"/ressources"},l=void 0,p={unversionedId:"ressources",id:"ressources",title:"Ressource Management",description:"Introduction",source:"@site/docs/reservation.md",sourceDirName:".",slug:"/ressources",permalink:"/vault/docs/ressources",draft:!1,editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/reservation.md",tags:[],version:"current",frontMatter:{id:"ressources",title:"Ressource Management",sidebar_label:"Ressource Management",slug:"/ressources"},sidebar:"someSidebar",previous:{title:"Immutability",permalink:"/vault/docs/immutability"},next:{title:"GraphQL",permalink:"/vault/docs/graphql"}},c={},u=[{value:"Introduction",id:"introduction",level:2},{value:"What this allows us to do!",id:"what-this-allows-us-to-do",level:2},{value:"Lifecycle of a Reservation",id:"lifecycle-of-a-reservation",level:3},{value:"Initialization",id:"initialization",level:5},{value:"Cycle",id:"cycle",level:5},{value:"And Even more fine grained control",id:"and-even-more-fine-grained-control",level:2},{value:"Generator  and Functions",id:"generator--and-functions",level:2},{value:"Function",id:"function",level:3},{value:"Generator",id:"generator",level:3},{value:"Advanced: Streams",id:"advanced-streams",level:2},{value:"Usage Example",id:"usage-example",level:2}],m={toc:u};function d(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"What even is a Reservation?"),(0,i.kt)("p",null,"If you have ever gone to a restaurant and didn't get a seat because everything was booked, you already experienced."),(0,i.kt)("p",null,"You have a microscope that can only run one experiment at a time, but you have multiple users accessing this resource and\nwanting to run their analysis at the same time."),(0,i.kt)("p",null,"Now organization of this resources doesnt even work with humans, so what is a way of dealing with that in programmatic code."),(0,i.kt)("p",null,"We already introduced the concept of asynchronous programming. One other little helper\nis a reservation."),(0,i.kt)("p",null,"consider this code snippet:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'stream = use(package="microscope", interface="well_stream")\nshow = use(package="elements", interface="show").on("napari@johannes")\n\nfor image in stream(well_x=3, well_y=3, interval=5):\n    show(image)\n\n\n')),(0,i.kt)("p",null,"Easy enough workflow right? You acquire images on the Well on Position X and Y every 5 seconds\nand then show the image to Johannes on his Napari instance.\nBut now someone in your lab is doing the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'stream = use(package="microscope", interface="well_stream")\nshow = use(package="elements", interface="show").on("napari@johannes")\n\nfor image in stream(well_x=8, well_y=6, interval=5):\n    show(image)\n\n')),(0,i.kt)("p",null,"Reservation to the rescue!"),(0,i.kt)("p",null,"Besides the integration of a messaging system between different apps,\nArkitekt also allows apps to declare policies on how they are able to be called\nconcurrently by different users, and if they want to instantiate again if other users\nare trying to call them."),(0,i.kt)("p",null,"Default Behaviour:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'\n@client.enable()\ndef calculate_intensity_maximum(rep: Representation): -> int\n    """\n    \n    \n    """\n    assert rep.variety = RepresentationVariety.VOXEL, "Your Image must be an intensity image!"\n    return rep.data.max()\n\n\n')),(0,i.kt)("p",null,"Think about this function. It takes an image and calculates its intensity without any other\ninteraction with anything outside this function. It doesn't alter anything outside of its scope.\nIt is ",(0,i.kt)("em",{parentName:"p"},"pure")," (fancy functional word). This type of function lends itself to be parallized and it doesn't really matter who assigns to it in which order ."),(0,i.kt)("p",null,"If we were dealing only with this sort of function, we could be happy and our analysis would parallelize\neasily. Sadly writing completely pure functions is not that trivial and if you every interacted with a microscope\nor another human being you realised that you cannot just spwan another human or microscope whenever you needed."),(0,i.kt)("p",null,"They are a limited resource, that means if we want to assign tasks to them we need to take this into account."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="app.py (with config.yaml of app: *sted-microscope*)"',title:'"app.py',"(with":!0,"config.yaml":!0,of:!0,"app:":!0,'*sted-microscope*)"':!0},'from arkitekt import Client\nfrom arkitekt.policy import GroupPolicy\nfrom microscope import MicroscopeAPI\nfrom elements import Representation\n\n\nclient = Client()\n\nmicroscope_api = MicroscopeAPI()\n\nmicroscope_policy = GroupPolicy( # This policy applies to a whole GROUP\n    instance = 1 # Allow only one instance in this group\n    users_per_instance = 1 # Allow only one user per instance in this group\n    user_roles = ["senior"] # Only seniors can reserve this microscope\n    provide_time = 3600 # Allow an hour of usage time until we \n)\n\n\n@client.enable(policy=microscope_policy,\n on_provide=lambda handler: microscope_api.ensure_multi_well_mode(),\n on_unprovide=lambda handler: microscope.turn_off()\n)  # Ensures the microscope is turned on and in well mode when somebody wants to stream wells, and make sure it is turned of afterwards\ndef stream_wells(well=5, interval=6): -> Representation\n\n    for i in well:\n        image = microscope_api.acquire_well(well)\n        yield Representation.objects.from_xarray(image)\n        time.sleep(interval)\n\n\n@client.enable(policy=microscope_policy, \n    on_provide=lambda handler: microscope_api.ensure_single_well_mode(),\n    on_unprovide=lambda handler: microscope.turn_off()\n)\ndef acquire_well(x=5): -> Representation\n    image = microscope_api.acquire_well(well)\n    return Representation.objects.from_xarray(image)\n\n\nclient.run()\n')),(0,i.kt)("p",null,"This ensures that if you want to call any of this function through arkitekt it will ensure that both stream_well\nand microscope are only being provided once at a time. Also it puts the microscope in different modes throughout\nthe entire time one user has ",(0,i.kt)("em",{parentName:"p"},"reserved")," this microscope (through on_provide, on_unprovide handlers). These methods have\nnow become ",(0,i.kt)("em",{parentName:"p"},"stateful"),"."),(0,i.kt)("h2",{id:"what-this-allows-us-to-do"},"What this allows us to do!"),(0,i.kt)("p",null,"Tom:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'acquire_well = use(package="microscope", interface="acquire_well")\nshow = use(package="elements", interface="show").on("napari@me")\n\nimage = acquire_well(x=5)\n\n\n')),(0,i.kt)("p",null,"Karl:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'stream = use(package="microscope", interface="acquire_well")\nshow = use(package="elements", interface="show").on("napari@me")\n\nfor image in stream(well_x=3, well_y=3, interval=5):\n    show(image)\n\n\n')),(0,i.kt)("p",null,"Both Tom and Karl can code their own workflows without bothering about the resources, or when they have the microscope.\nTheir script will just pause signalling a wait for the node to become active."),(0,i.kt)("h3",{id:"lifecycle-of-a-reservation"},"Lifecycle of a Reservation"),(0,i.kt)("h5",{id:"initialization"},"Initialization"),(0,i.kt)("p",null,"Reservation -> Acknowledged -> Waiting "),(0,i.kt)("h5",{id:"cycle"},"Cycle"),(0,i.kt)("p",null,"Active -> Failed -> Retry -> Critical"),(0,i.kt)("h2",{id:"and-even-more-fine-grained-control"},"And Even more fine grained control"),(0,i.kt)("p",null,"Tom wants his script to run after 20pm and on a connection lost cancel the script"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from arkitekt import Client, use\nimport elements\n\nacquire_well = await use(package="microscope", interface="acquire_well")\nshow = await use(package="elements", interface="show")\n\n\nimages = []\nasync with acquire_well.reserve(start="20.00pm", exit=["lost"]) as res:\n    images.append(await res.assign(x=5))\n\nasync with show.reserve(start="9.00pm", exit=["lost"]) as res:\n    for image in images:\n        await res.assign(image)\n\n')),(0,i.kt)("p",null,"And of course runs this snippet at the same time. What do you want to happen?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Do you want the second script to just fail?"),(0,i.kt)("li",{parentName:"ul"},"You might want the second script to run after the first one?"),(0,i.kt)("li",{parentName:"ul"},"YOu might want to pause the first script and intercept the second one?")),(0,i.kt)("p",null,"How can you even tell that to your program?"),(0,i.kt)("p",null,"Example:"),(0,i.kt)("p",null,"A microscope is a physical entitiy that doesnt allow any sort of parallelism. (You cannot just create another\nmicroscope on the fly now anyways)"),(0,i.kt)("p",null,"Resources in a lap environment are always limited and access needs to be controlled if we want to use workflows."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from bergen import Bergen, Node\nfrom elements import Representation\nimport matplotlib.pyplot as plt\n\n\nwith Bergen():\n    maxisp =use(package="basic", interface="maxisp")\n    \n    results = []\n    with maxisp.reserve(n=10, app="imagej") as res:\n        for rep in Representation.objects.filter(experiment="testing"):\n            results.append(res.assign({"rep": rep})\n            \n    plt.imshow(results[0].data)\n')),(0,i.kt)("p",null,"This Code will look for the MaxISP nodes and try to reserve 10 instances of the ImageJ version of this Node. Then it will will get all Representations filtered by the experiment name (testing) and for each of the rep its going to create a maxisp projection. (None of these tasks however will be run on the machine calling this). Please note that all of these tasks are running sequentially."),(0,i.kt)("p",null,"No we will takeone step into the asynchronous world:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from bergen import Bergen, Node\nfrom elements import Representation\nimport matplotlib.pyplot as plt\n\n\nasync with Bergen():\n    maxisp = await use(package="basic", interface="maxisp")\n    \n    async with maxisp.reserve(n=10, app="imagej") as pod:\n        results = []\n        for rep in await Representation.asyncs.filter(experiment="testing"):\n            results.append(await res.assign({"rep": rep})\n            \n        plt.imshow(results[0].data)\n')),(0,i.kt)("p",null,"Ignoring the insertion of the keywords async and await, and the change from ",(0,i.kt)("em",{parentName:"p"},"objects")," to ",(0,i.kt)("em",{parentName:"p"},"asyncs")," there are no changes to our original code. However this is running now in an event_loop and all of the functions are called in the back and we are just awaiting the result. As we are however always pairing our calls with awaits, we are really just doing what syncronous code would do us."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null},"Emulated Synchronous"),(0,i.kt)("th",{parentName:"tr",align:null},"Asynchronous"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Call"),(0,i.kt)("td",{parentName:"tr",align:null},"Parameters"),(0,i.kt)("td",{parentName:"tr",align:null},"Parameters")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Return"),(0,i.kt)("td",{parentName:"tr",align:null},"awaited Result"),(0,i.kt)("td",{parentName:"tr",align:null},"unawaited Result")))),(0,i.kt)("p",null,"Howere consider this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from bergen import Bergen, Node\nfrom elements import Representation\nimport matplotlib.pyplot as plt\nimport asyncio\n\nasync with Bergen():\n    maxisp = await Node.asyncs.get(package="basic", interface="maxisp")\n    \n    async with maxisp.provide(n=10, app="imagej") as pod:\n        unawaited_results = []\n        for rep in await Representation.asyncs.filter(experiment="testing"):\n            unawaited_results.append(pod.assign({"rep": rep}) # Omiting await\n            \n        results = await asyncio.gather(*unawaited_results)\n            \n        plt.imshow(results[0].data)\n')),(0,i.kt)("p",null,"We have ommited the await call in our loop, so what now happens it that during our loop arkitekt gets called with the input rep as fast as the loop progresses . Only when we await all of the unawaited_results with the asyncio.gather function (just a function that gathers and awaits all of the unawaited_results that we pass) through awaiting it. We are waiting for all tasks to be finished in ",(0,i.kt)("em",{parentName:"p"},"parallel"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Paralellizing computational workloads through asynchronous programmig is one interesting application of the Arkitekt framework, but frameworks as DASK are way better optimized  for distributing these workloads than Arkitekt ever will be. If you are searching just for a way to parallize your python workloads DASK is the solution you are searching for.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"  Arkitekt shines when using asynchronous programming to orchestrate multiple devices in analysis workflows.")),(0,i.kt)("h2",{id:"generator--and-functions"},"Generator  and Functions"),(0,i.kt)("p",null,"As discussed previously makes a destinction between two type of Nodes: [","[Nodes#Generator | Generators]","] and [","[Nodes#Function | Functions]","].  Generators will yield data in a constant stream (until they are completed or cancelled) and Functions will return one result for each call. This destinction is reflected in Arkitekts programming interface for this functions both on the [","[Pods#What is a Pod | pod ]","] and the client:"),(0,i.kt)("h3",{id:"function"},"Function"),(0,i.kt)("p",null,"Function just return 'normally' with a return. Once the functions returns or raises an Error it stops excecuting and sends the result as done."),(0,i.kt)("p",null,"Pod:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'pod = Pod(...)\n\n@pod.host(package="basic", interface="maxisp", gpu=True)\ndef maxisp(helper, rep: Representation, dim: str = "z") -> Representation:\n    maxed = rep.data.max(dim=dim)\n    \n    output = Representation.objects.from_xarray(maxed)\n    return output\n    \npod.run()\n\n')),(0,i.kt)("p",null,"Client:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'async with Client(...)\n    maxisp = await Node.asyncs.get(package="basic", interface="interface")\n    rep = Representation.objects.get(name="best_sample")\n    result = await maxisp(rep=rep)\n\nplt.imshow(result.data)\n')),(0,i.kt)("h3",{id:"generator"},"Generator"),(0,i.kt)("p",null,'Generators are called ONCE and are yielding data until they are finished ("intermediate results"). This yielded result is then automatically put  into a stream for arkitekt and can be consumed by the client iterating over the result.'),(0,i.kt)("p",null,"Pod:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'pod = Pod(...)\n\n@pod.host(package="micro", interface="timeseries", room="sted")\ndef timeseries(helper, t: int, x: int = 1000, y: int: 1000, z: int = 1) -> Representation:\n    for i in range(t):\n        # Acquire Image logic\n        stack = acquire(x,y,z)\n        rep = Representation.objects.from_xarray(stack)\n        yield rep\n    \npod.run()\n')),(0,i.kt)("p",null,"Client:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'async with Client(...)\n    maxisp = await Node.asyncs.get(package="micro", interface="timeseries")\n    async with maxisp.provide(room="sted") as pod:\n        async with pod.stream({"x": 100, "y": 100, "z": 30, "t"=10 }) as stream:\n            async for result in stream:\n                print(result)\n    \n    \n')),(0,i.kt)("h2",{id:"advanced-streams"},"Advanced: Streams"),(0,i.kt)("p",null,"Asynchronous programming helps simplifiyng a lot of modern analysis worklflows and makes complex workflows more humanly readable. However the async and await syntax can be intimidating for even seasoned developers as in more complex setups it becomes increasingly dificults to manage async and awaits."),(0,i.kt)("p",null,"A more accessible abstraction for many has become Reactive Programming, a style of programming popularized by the Rx Family of Language extensions (Especially RxJavascript has seen a lot of attention). This is why we choose it as a paradigm for our visual flow programming interface. ( with some minor adjustments). And also allow programmatic access through the Python interface."),(0,i.kt)("p",null,"In Reactive Programming we are concerened with Data Streams. This Streams originiated from Observables that are pushing data down the Streams, where this data is passed through a pipe of operations that alter the data in the stream and are finally consumed by a Subscriber. "),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Stream processing with the Reactive Extensions has not seen a massive adoption in the Python ecosystem and the packages are poorly maintainted. If you want to use streams. Make sure you check out our Javascript client.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"As the aioreactive extensions have a hard reliance on Python 3.9 this is an opt in feature of the python client, currently as it is still a pre release arkitekt client ships with aiostreams")),(0,i.kt)("h2",{id:"usage-example"},"Usage Example"),(0,i.kt)("p",null,"Multiple Microscopes:"),(0,i.kt)("p",null,"Your experimental design requires you to  acquire images with to microscope modalitites at the same time and then combine their images in a processing pipeline."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from bergen import Bergen, Node\nfrom elements import Representation\nfrom aiostream import stream, pipe\n\nasync with Bergen():\n    timeseries = await Node.asyncs.get(package="micro", interface="stack")\n    combine_reps = await Node.asyncs.get(package="custom", interface="combine_reps")\n    \n    # Provide or Select Pods running on Multiple Devices\n    sted_timeseries = await timeseries.provide(device="sted")\n    palm_timeseries = await timeseries.provide(device="palm")\n    \n    params = {\n    "x": 1000,\n    "y": 1000,\n    "z": 10,\n    }\n    \n    merged = stream.zip(\n        sted_timeseries.stream(params),\n        palm_timeseries.stream(params)\n    )\n    \n    processed = merged | pipe.map(lambda two_reps: channel_merge({"reps": two_reps}))\n    \n    \n    async with processed.stream() as stream:\n        async for result in stream:\n            # Do stuff here\n            plt.imshow(result.data)\n\n\n')))}d.isMDXComponent=!0}}]);