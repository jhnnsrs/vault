"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7127],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return f}});var r=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(t),f=o,v=d["".concat(l,".").concat(f)]||d[f]||p[f]||a;return t?r.createElement(v,s(s({ref:n},u),{},{components:t})):r.createElement(v,s({ref:n},u))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,s=new Array(a);s[0]=d;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var c=2;c<a;c++)s[c]=t[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},61212:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return p}});var r=t(87462),o=t(63366),a=(t(67294),t(3905)),s=["components"],i={id:"scheduler",title:"Scheduler",sidebar_label:"Scheduler",slug:"/scheduler"},l=void 0,c={unversionedId:"scheduler",id:"scheduler",title:"Scheduler",description:"Scheduler",source:"@site/docs/scheduler.md",sourceDirName:".",slug:"/scheduler",permalink:"/vault/docs/scheduler",draft:!1,editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/scheduler.md",tags:[],version:"current",frontMatter:{id:"scheduler",title:"Scheduler",sidebar_label:"Scheduler",slug:"/scheduler"}},u={},p=[{value:"Scheduler",id:"scheduler",level:2},{value:"What happens",id:"what-happens",level:3}],d={toc:p};function f(e){var n=e.components,t=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"scheduler"},"Scheduler"),(0,a.kt)("p",null,"Scheduler try to create a provision mapping from a reservation."),(0,a.kt)("p",null,"Image you specify a reservation like this"),(0,a.kt)("p",null,"Provide Maximum Intensity Node and paralleize it using preferably\nfive instances, preferably again on on agent"),(0,a.kt)("p",null,"ImageJ implements this Task and allows for one task per connected agent.\nNapari implements this Task and allows for one task per connected agent.\nCluster implements this Task and allows for two task per connected agent."),(0,a.kt)("h3",{id:"what-happens"},"What happens"),(0,a.kt)("p",null,"We send this reservation to the scheduler."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'\ndesired_amount =\nall_templates = Templates.filter(node="@elements/maxisp")\n\n# find assignable ACTIVE provisions\nactive_provisions = provisions.filter(templates__in=all_templates).filter(active=true).assignable_for(user=reservation.user, app=reservaion.app)\n\nfor aprov in active_provisions:\n    messages += add_reservation_to_provision(aprov)\n\nif len(active_provisions) < desired_amount:\n    assert can_provide(user, app), "User cannot create new Provisiosn"\n\n\n    qs =  Templates.filter(node="@elements/maxisp")\n    if res.params.prefer_active == True:\n        qs = qs.sort(app_agents_active == True) # prefer templates who have an app with at least on active agent\n\n    qs = qs[:desired_amount]\n\n    if reserve.agent:\n        send_to_private_agent_queue(reserve.agent)\n    else:\n        send_to_app_queue() # a queue where all agents listen to\n\n\n    create_provision()\n\n\n\ntemplates.sort()\n\n')),(0,a.kt)("p",null,"Agent"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/19304157/getting-the-reason-why-websockets-closed-with-close-code-1006"},"https://stackoverflow.com/questions/19304157/getting-the-reason-why-websockets-closed-with-close-code-1006")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'\nAlreadyConnectedError = 3990\n\n\non_connect:\n    check if Agent already connected:\n        self.close(AlreadyConnectedError)\n\n    token and qs.websocket_identifier = "main"\n    \n    \n    get_provisions_filter_active\n    subcribe prive_agent_queue\n    subscribt all_agent_queue\n\non_provision:\n    on provide:\n        send provisionbindmessage\n        if provision.status == CANCELLED = "Ommit this Provision" # This is a race condition catcher because it could still be in the queue\n        provide.agent = this.agent\n\n    on_unprovide:\n        if unprovision successfull:\n            check if we need to change the reservation:\n                \n\n')),(0,a.kt)("p",null,"Scheduler"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'\nunreserve:\n\n\n\n    for prov in reservation:\n\n        if needs to kill other:\n            if provision.agent is None: \n                log("It was nether bound to an actor")\n                provision.status = CANCELLED\n                pass\n            send_to_private_agent_queue(reserve.agent)        \n\n\n\n\n\n\n\nUnprovide\n\n```python\n\nif prpvision\n\n\n\n\n\n')))}f.isMDXComponent=!0}}]);